### <a  id="top" href="#top">:closed_book:目录 </a>



- [x] <a href="#01">**`委托的同步调用`**</a>
- [x] <a href="#02">**`委托的异步调用`**</a>
- [x] <a href="#03">**``**</a>
- [x] <a href="#04">**``**</a>
- [x] <a href="#05">**``**</a>
- [x] <a href="#06">**``**</a>
- [x] <a href="#07">**``**</a>
- [x] <a href="#08">**``**</a>

### &nbsp;&nbsp; <a id="01">委托的同步调用</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 所有任务都通过主线程执行
```csharp
using System;

using System.Threading;

namespace CarLibary
{
    public delegate int Show(int a, int b);


    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("现在进行的线程ID  {0}", Thread.CurrentThread.ManagedThreadId);

            Show sh = new Show(Add);

            int answer = sh.Invoke(10, 5);  //同步调用

            //直到Add()方法执行完毕，这行代码才会执行
            Console.WriteLine("main函数还未执行完毕！");
            Console.WriteLine("10+5={0}", answer);


        }


        static int Add(int a,int b)
        {
            Console.WriteLine("Add() invoke on thread  {0}", Thread.CurrentThread.ManagedThreadId);

            Thread.Sleep(3000);  //等待3秒
            return a + b;
        }

    }
}
```
```csharp
--输出结果
现在进行的线程ID  1
Add() invoke on thread  1
main函数还未执行完毕！
10+5=15
```



---
### &nbsp;&nbsp; <a id="02">委托的异步调用</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 异步调用方法
```csharp
using System;

using System.Threading;

namespace CarLibary
{
    public delegate int Show(int a, int b);
    class Program
    {
        static void Main(string[] args)
        {
            //输出正在执行的线程ID
            Console.WriteLine("现在进行的线程ID  {0}", Thread.CurrentThread.ManagedThreadId);

           //在次线程中调用Add();
            Show sh = new Show(Add);
            IAsyncResult iftAR = sh.BeginInvoke(10, 5, null, null);


            while (!iftAR.IsCompleted) //IAsyncResult 接口的IsCompleted方法
            {
                Console.WriteLine("异步调用尚未完成!");
                Thread.Sleep(1000);   //只是让这个while循环隔1s执行一次
            }
            
            //IAsyncResult 接口的AsyncWaitHandle属性，该属性返回一个waitHadle类型的实例，该实例公开了一个WaitOne()方法
            while (!iftAR.AsyncWaitHandle.WaitOne(1000, true))  //指定最长等待时间，超时则返回false
            {
                Console.WriteLine("hhh");
            }

            //直到Add()方法执行完毕，这行代码才会执行
            int answer = sh.EndInvoke(iftAR);    //结启动的线程，并通过参数接收，才能获得结果，

            Console.WriteLine("main函数还未执行完毕！");
            Console.WriteLine("10+5={0}", answer);
        }
        static int Add(int a,int b)
        {
            Console.WriteLine("Add() invoke on thread  {0}", Thread.CurrentThread.ManagedThreadId);

            Thread.Sleep(3000);
            return a + b;
        }

    }
}

```

```csharp
--结果
现在进行的线程ID  1
Add() invoke on thread  3
main函数还未执行完毕！
10+5=15
```




:star: AsyncCallback委托的作用


:star: 同步调用线程

---
### &nbsp;&nbsp; <a id="03"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="04"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="05"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="06"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="07"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star:

### &nbsp;&nbsp; <a id="08"></a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star:

---











