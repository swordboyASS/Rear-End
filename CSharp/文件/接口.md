

<p id="title"></p>

## 目录

:arrow_down:<a href="#01">定义，实现，调用接口</a>

:arrow_down:<a href="#02">接口作为参数，返回值，接口数组</a>

:arrow_down:<a href="#03">构建可枚举类型</a>

:arrow_down:<a href="#0">构建可克隆对象、可比较对象</a>


<p id="01"></p>

:arrow_double_up:<a href="#title">返回目录</a>

### 定义，实现，调用接口
和抽象方法类似的，接口也只有简单的签名（协议），没有提供默认的实现---方法体内没有内容。

---接口以大写字母"I"为前缀--命名规则。

从语法级别来说，接口使用C#interface关键字来定义。和类不一样的是，接口不指定基类（即使是System.Object；然而，正如你在本章将看到的那样，接口可以指定基接口）。而且接口的成员也不指定访问修饰符（因为所有接口成员都是隐式公共的和抽象的）（记住这句话）。这里是一个使用C#定义的自定义接口：
```csharp
//这个接口定义了“具有顶点”的行为
public interface IPointy
{
//隐式公共的和抽象的
byte GetNumberOfPoints()；
}
```

```csharp
//内有大量错误
public interface IPointy
{
//错误！接口不能有字段
public int numbofPoints；
//错误！接口不能有构造函数
public IPointy(){numbofPoints=o；}；
//错误！接口不能提供实现
byte cetNumberofPoints（）{return numbofPoints；}
}
```

```csharp
//这个pointy表现为一个只读属性
public interface IPointy
//在接口中的读写属性差不多是retType PropName{get;set;}
//而接口中的只写属性是retType PropName{set;}
byte Points{get;}
```
不能创建结构的实例，不能分配空间。
`IPointy p = new IPonity` //编译错误

#### 接口实现类似多继承。

<p id="02"></p>

:arrow_double_up:<a href="#title">返回目录</a>

### 接口作为参数，返回值，接口数组




<p id="03"></p>

:arrow_double_up:<a href="#title">返回目录</a>

### 构建可枚举类型


<p id="04"></p>

:arrow_double_up:<a href="#title">返回目录</a>
### 构建可克隆对象、可比较对象


