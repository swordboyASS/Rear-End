### <a  id="top" href="#top">:closed_book:目录 </a>



- [x] <a href="#01">**`继承`**</a>
- [x] <a href="#02">**`终结类与终结方法`**</a>
- [x] <a href="#03">**`抽象类`**</a>
- [x] <a href="#04">**`组合类`**</a>
- [x] <a href="#05">**`包的应用`**</a>
- [x] <a href="#06">**`接口`**</a>
- [x] <a href="#07">**`塑性`**</a>
- [x] <a href="#08">**`多态`**</a>

### &nbsp;&nbsp; <a id="01">继承</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 父类引用指向子类对象   
父类引用指向子类对象，即创建一个子类对象让父类进行接收，生成的对象可以调用父类的方法，但是当子类中存在与父类相同的方法时发生覆盖现象；如果想要调用子类特有的方法时需要向下转型，即将父类强制转化为子类然后对子类方法进行调用。

:star: 覆盖和隐藏现象

1. 隐藏:子类对从父类继承来的属性变量重新加以定义，则从父类定义的属性将被隐藏 访问父类被隐藏的属性:super.prop
2. 覆盖:子类对从父类继承来的方法重新加以定义,则从福恶劣定义的方法被隐藏，super.method，可以调用父类中的同名方法。

```java
继承关键字：extends
```
:star: 子类自动调用父类默认构造函数(无参)    
1. 子类的所有构造方法的第一行都有一条隐身的语句super
2. 因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

:star: Object类

1.相等一同一(==)   
判断两个对象是否相同，a==b。除了直接将b赋值给a返回true外，其余方式都返回false；

2.Object类的equals()方法      
直接从Object继承而来的equals()方法比较的也是两个对象是否同一(==)，而不会是比较属性值是否相等。

3. equals()方法的重写
```java
@Override
publice boolean equals(Object x){
  if(将两个要比较的对象转化为字符串的方法){
      return true;
  } 
}
```


---
### &nbsp;&nbsp; <a id="02">终结类与终结方法</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: final关键字  
1. 如果一个类被final修饰符所修饰限定，说明这个类不能有子类，即不能被继承。但可以创建实例
2. final修饰的方法，这个方法规定本方法不能被修改。子类也不能通过继承达到覆盖的目的。
---
### &nbsp;&nbsp; <a id="03">抽象类</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 抽象类(abstract)
1. 抽象类不能创建实例，即new关键字分配空间无效。
2. 抽象类中可以包含构造方法、可以包含非抽象方法、包含抽象方法、
3. 抽象方法只能声明在抽象类中，且只能包含方法签名，不能有任何实现。且子类必须实现所有抽象方法。

:star:为什么要声明抽象类。
1. 抽象类是类层次中较高层次的概括，抽象类的作用是让其他类来继承它的抽象化的特征。
2. 在抽象类中可以包括被它的所有子类共享的公共行为。
3. 抽象类可以包括被它的所有子类共享的公共属性
4. 抽象类不能用作模板来创建对象。
5. 强迫用户生成更具体的实例，保证代码的安全性。



---
### &nbsp;&nbsp; <a id="04">组合类</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>
  
:star: 泛型
```java
泛型类  class A<Type>{}
泛型方法 <Type> void methodName(Type object){}

---有类型限制的泛型
class A<Type extends Number>{}  --限制类型为Number的对象类型

---通配符泛型
public void methodName(GeneralType<?> o){}
```


:star: 什么是类的组合(has-a模型)--继承则是(is-a模型)   
在一个类中创建另一个类的对象。

---
### &nbsp;&nbsp; <a id="05">包的应用</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="06">接口</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star: 

---
### &nbsp;&nbsp; <a id="07">塑性</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star:

### &nbsp;&nbsp; <a id="08">多态</a>&nbsp;&nbsp;<a href="#top">:blue_book:</a>

:star:

---











